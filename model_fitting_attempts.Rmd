```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE, fig.width=8, fig.height=6)
library(forecast)
library(dplyr)
```

# Transit Ridership SARIMA Analysis

## 1. Data Preparation

```{r data-prep}
# Define AICC function exactly as in the homework
arima.AICC <- function(fit) {
  n.par <- length(fit$coef) - sum((fit$coef == 0))
  n <- fit$nobs
  aicc <- -2 * fit$loglik + 2 * (n.par + 1) * n / (n - n.par - 2)
  return(aicc)
}

# Set seed for reproducibility 
set.seed(250)

# Select 5 random jurisdictions
selected_ntd_ids <- sample(complete.jurisdictions$NTD.ID, 5)
cat("Selected jurisdiction IDs:", paste(selected_ntd_ids, collapse=", "), "\n")
```

## 2. Grid Search for Best SARIMA Models

```{r grid-search, results='hide'}
detect_seasonality_for_tbats <- function(train_data, max_periods = 3, 
                                        allowed_periods = c(2, 3, 4, 6, 12),
                                        always_include_annual = TRUE) {
  # Validate input
  if(!is.ts(train_data)) {
    stop("Input must be a time series (ts) object")
  }
  
  if(length(train_data) < 36) {
    warning("Time series is short (<36 points). Results may be unreliable.")
  }
  
  # Calculate spectrum 
  spec <- tryCatch({
    stats::spectrum(train_data, spans = c(3, 3), plot = FALSE, na.action = na.omit)
  }, error = function(e) {
    warning("Spectrum calculation failed: ", conditionMessage(e))
    return(NULL)
  })
  
  # If spectrum calculation failed, try fallback
  if(is.null(spec) || length(spec$spec) == 0 || all(is.na(spec$spec))) {
    return(fallback_seasonality(train_data))
  }
  
  # Find peaks in spectrum
  spec_values <- spec$spec
  peaks_idx <- which(diff(sign(diff(spec_values))) < 0) + 1
  
  # If no peaks found, try fallback
  if(length(peaks_idx) == 0) {
    return(fallback_seasonality(train_data))
  }
  
  # Calculate periods from peaks
  peak_freqs <- spec$freq[peaks_idx]
  periods <- ifelse(peak_freqs > 1e-9, round(1 / peak_freqs), Inf)
  
  # Filter valid periods
  valid_periods_idx <- which(periods %in% allowed_periods)
  
  # If no valid periods, try fallback
  if(length(valid_periods_idx) == 0) {
    return(fallback_seasonality(train_data))
  }
  
  # Select and order periods by strength
  valid_periods <- periods[valid_periods_idx]
  peak_strengths <- spec_values[peaks_idx[valid_periods_idx]]
  
  valid_periods <- valid_periods[order(peak_strengths, decreasing = TRUE)]
  valid_periods <- unique(valid_periods)
  
  # Limit to max periods
  if(length(valid_periods) > max_periods) {
    valid_periods <- valid_periods[1:max_periods]
  }
  
  # Add annual seasonality if requested and not already present
  base_freq <- frequency(train_data)
  if(always_include_annual && base_freq == 12 && !any(valid_periods == 12)) {
    freq_12_idx <- which.min(abs(spec$freq - 1/12))
    strength_12 <- if(length(freq_12_idx) > 0) spec$spec[freq_12_idx] else 0
    
    # Only add if it has some strength (5% of max peak)
    if(strength_12 > (max(spec$spec[peaks_idx[valid_periods_idx]], na.rm=TRUE) * 0.05)) {
      valid_periods <- unique(sort(c(valid_periods, 12)))
    }
  }
  
  # Return detected periods, ensuring non-empty result
  if(length(valid_periods) == 0) {
    return(fallback_seasonality(train_data))
  }
  
  return(valid_periods)
}

# Helper function for fallback seasonality
fallback_seasonality <- function(train_data) {
  base_freq <- frequency(train_data)
  
  # Check if there's seasonal differencing needed
  num_diffs <- tryCatch(
    forecast::nsdiffs(train_data, m=base_freq, test="ocsb"), 
    error = function(e) 0
  )
  
  if(num_diffs > 0 && base_freq > 1) {
    return(base_freq)  # Return base frequency (usually 12 for monthly data)
  } else {
    return(NULL)  # No seasonality detected
  }
}
find_best_model <- function(ntd_id, max_order = 2) {
  # Prepare data
  jur_data <- transit.complete %>%
    filter(NTD.ID == ntd_id) %>%
    arrange(date)

  ts_data <- ts(jur_data$UPT.sum,
                start=c(2002, 1),
                frequency=12)

  # Cut off data after 2019 (covid and on)
  train_data <- window(ts_data, end=c(2019, 12))

  #Handles outliers in data ~ should help with box tests
  train_data <- forecast::tsclean(train_data)


  cat("Fitting models for jurisdiction", ntd_id, "...\n")
  models <- list()

  # Determine differencing orders
  D_determined <- forecast::nsdiffs(train_data, m=12)
  d_determined <- if(D_determined > 0) {
    forecast::ndiffs(diff(train_data, lag=12, differences=D_determined))
  } else {
    forecast::ndiffs(train_data)
  }

  # Manual Grid Search
  best_manual_model <- NULL
  best_manual_name <- "Manual: None Found/Converged"

  # Fit manual models
  results_manual <- data.frame()

  # Grid search (loop through all possible models up to max.order)
  for(p in 0:max_order) for(q in 0:max_order) for(P in 0:max_order) for(Q in 0:max_order) {
      # Skip invalid models
      if(p == 0 && q == 0 && P == 0 && Q == 0 && (d_determined > 0 || D_determined > 0)) next
      if(p == 0 && q == 0 && P == 0 && Q == 0 && d_determined == 0 && D_determined == 0) next

      model_name <- sprintf("Manual: SARIMA(%d,%d,%d)×(%d,%d,%d)_%d",
                           p, d_determined, q, P, D_determined, Q, 12)

      fit_result_row <- NULL
      current_fit <- NULL

      tryCatch({
          # Fit model
          current_fit <- stats::arima(train_data,
                                      order=c(p, d_determined, q),
                                      seasonal=list(order=c(P, D_determined, Q), period=12))

          # Calculate AICc 
          current_aicc <- arima.AICC(current_fit)

          # Return results
          fit_result_row <- data.frame(
              model = model_name,
              AICC = current_aicc, 
              converged = TRUE
          )

      }, error = function(e) {
          fit_result_row <- data.frame(
              model = model_name, AICC = NA, converged = FALSE
          )
      })

      # Add if successful
      if(!is.null(fit_result_row)) {
        results_manual <- rbind(results_manual, fit_result_row)
      }
      # Store model object if successful
      if(!is.null(current_fit)) {
        models[[model_name]] <- current_fit
      }
  }

  # Find best manual model
  valid_manual_results <- results_manual[!is.na(results_manual$AICC) & results_manual$converged,]
  if(nrow(valid_manual_results) > 0) {
      best_manual_idx <- which.min(valid_manual_results$AICC) 
      best_manual_name <- valid_manual_results$model[best_manual_idx]
      best_manual_model <- models[[best_manual_name]]
  } else {
      cat("No valid manual models converged.\n")
  }

  # Auto ARIMA
  cat("Running auto.arima...\n")
  auto_model <- NULL
  auto_name <- "Auto: FAILED"
  auto_aicc <- NA # Store AICc for reporting

  tryCatch({
      auto_model_fit <- forecast::auto.arima(train_data, seasonal=TRUE, stepwise=FALSE,
                                           approximation=FALSE,
                                           ic="aicc") # Use AICc for selection

      if(!is.null(auto_model_fit)) {
          auto_model <- auto_model_fit
          order <- forecast::arimaorder(auto_model)
          auto_name <- sprintf("Auto: SARIMA(%d,%d,%d)x(%d,%d,%d)_%d",
                              order[1], order[2], order[3],
                              order[4], order[5], order[6], order[7])
          models[[auto_name]] <- auto_model
          auto_aicc <- auto_model$aicc # Get AICc directly from forecast object for reporting
          cat("Auto ARIMA model fitted:", auto_name, "\n")
      }
  }, error = function(e) {
      cat("Auto ARIMA failed:", conditionMessage(e), "\n")
  })

  # TBATS
  cat("Running tbats...\n")
  tbats_model <- NULL
  tbats_name <- "TBATS: FAILED"
  tbats_aicc <- NA # Store AICc/AIC for reporting

  tryCatch({
      detected_periods <- detect_seasonality_for_tbats(train_data)
if(is.null(detected_periods)) {
      cat("No seasonality detected, using non-seasonal TBATS model\n")
      detected_periods_str <- "None"
    } else {
      cat("Detected seasonal periods for jurisdiction", ntd_id, ":", 
          paste(detected_periods, collapse=", "), "\n")
      detected_periods_str <- paste(detected_periods, collapse=", ")
    }
    
    # Fit TBATS with detected seasonality (or without if NULL)
    tbats_model_fit <- if(is.null(detected_periods)) {
      forecast::tbats(train_data,  ic="aicc")
    } else {
      forecast::tbats(train_data, seasonal.periods = detected_periods,
                     ic="aicc")
    }

      if(!is.null(tbats_model_fit)) {
          tbats_model <- tbats_model_fit

          # Get AIC directly from tbats object for reporting (closest metric used for AICc selection)
          tbats_aicc <- tbats_model$AIC

          # Create descriptive name
          p_tbats <- tbats_model$p; q_tbats <- tbats_model$q
          box_cox_value <- if(!is.null(tbats_model$lambda)) sprintf("%.2f", tbats_model$lambda) else "N"
          has_trend <- !is.null(tbats_model$beta) && abs(tbats_model$beta) > 1e-10
          is_damped <- has_trend && !is.null(tbats_model$damping.parameter) && tbats_model$damping.parameter < 0.999
          season_desc <- paste(sprintf("%d[k=%d]", tbats_model$seasonal.periods, tbats_model$k.vector), collapse=",")

          tbats_name <- sprintf("TBATS(BC=%s, T=%s, D=%s, ARMA={%d,%d}, S=[%s])",
                                box_cox_value, if(has_trend) "Y" else "N", if(is_damped) "Y" else "N",
                                p_tbats, q_tbats, season_desc)

          models[[tbats_name]] <- tbats_model
          cat("TBATS model fitted.\n")
      }
  }, error = function(e) {
      cat("TBATS failed:", conditionMessage(e), "\n")
  })

  # Return Results
  return(list(
      best_manual_model = best_manual_model,
      best_manual_name = best_manual_name,
      auto_model = auto_model,
      auto_name = auto_name,
      tbats_model = tbats_model,
      tbats_name = tbats_name,
      model_comparison = list(
          manual_aicc = if(!is.null(best_manual_model)) arima.AICC(best_manual_model) else NA, # Use your function
          auto_aicc = auto_aicc,               # Use stored AICc from auto.arima object
          tbats_aicc = tbats_aicc              # Use stored AIC from tbats object
      ),
      models = models,
      d_determined = d_determined,
      D_determined = D_determined,
      train_data = train_data
  ))
}


all_results <- list()
for (id in selected_ntd_ids) {
  all_results[[as.character(id)]] <- find_best_model(id, max_order = 3)
}
```

```{r compare-print}
compare_models_pdf <- function(id, result) {
  # Enhanced helper function to plot diagnostics & calculate tests for a model
  analyze_model <- function(model) {
    # Initialize results storage
    test_results <- list(
      lb_tests = list(),
      norm_test = NULL,
      arch_test = NULL,
      acf_significant = FALSE,
      info_criteria = list()
    )
    
    if(is.null(model)) {
      for(i in 1:6) { # If no model print empty plots (now 6 plots)
          plot(1, type="n", axes=FALSE, xlab="", ylab="")
          if(i == 1) text(1, 1, "No model", cex=1.2)
      }
    } else {
      tryCatch({
          # Extract residuals and fitted values
          res <- residuals(model)
          if (!is.ts(res)) res <- ts(res)
          
          # Get fitted values if available
        
          # Determine plot lag for ACF/PACF
          plot_lag_max <- min(36, length(res) - 1)
          if(plot_lag_max < 1) plot_lag_max <- 1

          # Determine standardized y-axis limits for residuals
          y_range <- range(res, na.rm = TRUE)
          y_limit <- max(abs(y_range)) * 1.1
          
          # 1. Plot residuals with standardized scale
          plot(res, main="Residuals", ylab="", xlab="", ylim=c(-y_limit, y_limit))
          abline(h=0, col="red", lty=2)
          
          # 2. ACF plot
          acf_result <- acf(res, main="ACF", lag.max=plot_lag_max, plot=TRUE)
          
          # Store if any significant ACF values exist (excluding lag 0)
          test_results$acf_significant <- any(abs(acf_result$acf[-1]) > qnorm(0.975)/sqrt(length(res)))
          
          # 3. PACF plot
          pacf(res, main="PACF", lag.max=plot_lag_max)
          
          # 4. Histogram with density curve
          hist(res, freq=FALSE, main="Histogram", breaks=20, xlab="")
          curve(dnorm(x, mean=mean(res), sd=sd(res)), add=TRUE, col="red", lwd=2)
          
          # 5. Q-Q Plot
          qqnorm(res, main="Q-Q Plot")
          qqline(res, col="red")
          
          # 6. Fitted vs Actual (if available)
          # More robust approach to get original data and fitted values
          original_data <- NULL

    
          #  Parameters count and Ljung-Box Calculation
          n_params <- 0
          if(inherits(model, "Arima")) { 
              n_params <- length(coef(model)) - sum(coef(model) == 0)
          } else if(inherits(model, "tbats") || inherits(model, "bats")) {
               n_params <- model$p + model$q  # ARMA parameters
    
              # Add seasonal component parameters
              for(i in 1:length(model$seasonal.periods)) {
                  n_params <- n_params + 2 * model$k.vector[i]
              }
    
              # Add trend/damping if present
              if(!is.null(model$beta) && abs(model$beta) > 1e-10) n_params <- n_params + 1
              if(!is.null(model$damping.parameter) && model$damping.parameter < 0.999) n_params <- n_params + 1
    
              # Add Box-Cox parameter if used
              if(!is.null(model$lambda)) n_params <- n_params + 1
          }
          n_params <- max(0, n_params) 

          # Multiple lag Ljung-Box testing
          # Test at lags 10, 20, and min(2*frequency, 30) if applicable
          test_lags <- c(10, 20)
          
          # Add a seasonal lag if possible
          freq <- 1
          if(is.ts(res) && frequency(res) > 1) {
            freq <- frequency(res)
            seasonal_lag <- min(2*freq, 30)
            test_lags <- unique(c(test_lags, seasonal_lag))
          }
          
          # Sort and ensure lags are valid (greater than n_params)
          test_lags <- sort(test_lags)
          test_lags <- test_lags[test_lags > n_params]
          
          # Run Ljung-Box test for multiple lags
          for(lag in test_lags) {
            if(length(res) > lag) {
              lb_test <- stats::Box.test(res, lag=lag, type="Ljung-Box", fitdf=n_params)
              test_results$lb_tests[[paste0("lag_", lag)]] <- lb_test
            }
          }
          
          # Normality test (Shapiro-Wilk)
          # Limit to 5000 observations if more exist (limitation of shapiro.test)
          if(length(res) > 0) {
            if(length(res) > 5000) {
              # Sample 5000 observations randomly
              test_results$norm_test <- shapiro.test(sample(res, 5000))
              test_results$norm_test$note <- "Test on random sample of 5000 observations"
            } else {
              test_results$norm_test <- shapiro.test(res)
            }
          }
          
          # ARCH test for heteroscedasticity (using squared residuals)
          arch_lag <- min(12, length(res) - 1)
          if(arch_lag > 0) {
            test_results$arch_test <- Box.test(res^2, lag=arch_lag, type="Ljung-Box")
          }
          
          # Seasonal decomposition test if frequency > 1
          if(is.ts(res) && frequency(res) > 1 && length(res) >= 2*frequency(res)) {
            tryCatch({
              # Attempt to detect remaining seasonality
              test_results$seasonal_test <- TRUE
              # Extract seasonal component, if any
              decomp <- decompose(ts(res, frequency=frequency(res)), type="additive")
              # Test if seasonal component has significant variance
              seasonal_var <- var(decomp$seasonal, na.rm=TRUE)
              random_var <- var(decomp$random, na.rm=TRUE)
              test_results$seasonal_ratio <- seasonal_var / (seasonal_var + random_var)
            }, error = function(e) {
              # Seasonal decomposition might fail for some time series
              test_results$seasonal_test <- FALSE
            })
          }

      }, error = function(e) {
          warning("Diagnostics failed: ", conditionMessage(e))
          for(i in 1:6) { # Now we expect 6 plots
            plot(1, type="n", axes=FALSE, xlab="", ylab="")
            if(i == 1) text(1, 1, "Diag Error", cex=1.2)
          }
      })
    }
    return(test_results) # Return all the test results
  }

  # Format test results as a string
  format_model_results <- function(model_type, test_results, model_name = "(Name N/A)") {
    # Ensure model_name is printable
    model_name_print <- ifelse(is.null(model_name) || model_name == "", "(Name N/A)", model_name)
    result <- paste0(model_type, " model: ", model_name_print, "\n")
    
    # Add Information Criteria
    if(length(test_results$info_criteria) > 0) {
      result <- paste0(result, "  Information Criteria:\n")
      for(criterion in names(test_results$info_criteria)) {
        if(!is.null(test_results$info_criteria[[criterion]])) {
          result <- paste0(result, sprintf("    %s: %.2f\n", criterion, test_results$info_criteria[[criterion]]))
        }
      }
      result <- paste0(result, "\n")
    }

    # Add Ljung-Box results
    if(length(test_results$lb_tests) > 0) {
      result <- paste0(result, "  Ljung-Box Tests:\n")
      for(lag_name in names(test_results$lb_tests)) {
        lb_test <- test_results$lb_tests[[lag_name]]
        lag <- lb_test$parameter[1]
        pval <- lb_test$p.value
        result_text <- ifelse(pval > 0.05, "PASS", "FAIL")
        result <- paste0(result, sprintf("    lag=%d: X2=%.2f, p=%.3g, %s\n", 
                                      lag, lb_test$statistic, pval, result_text))
      }
    } else {
      result <- paste0(result, "  Ljung-Box tests: Skipped or Failed\n")
    }
    
    # Add Normality test results
    if(!is.null(test_results$norm_test)) {
      norm_pval <- test_results$norm_test$p.value
      norm_result <- ifelse(norm_pval > 0.05, "PASS (normal)", "FAIL (not normal)")
      result <- paste0(result, sprintf("  Normality: W=%.3f, p=%.3g, %s\n", 
                                    test_results$norm_test$statistic, norm_pval, norm_result))
    }
    
    # Add ARCH test results
    if(!is.null(test_results$arch_test)) {
      arch_pval <- test_results$arch_test$p.value
      arch_result <- ifelse(arch_pval > 0.05, "PASS (const. var.)", "FAIL (ARCH effects)")
      result <- paste0(result, sprintf("  ARCH test: X2=%.2f, p=%.3g, %s\n", 
                                    test_results$arch_test$statistic, arch_pval, arch_result))
    }
    
    # Add seasonality test if available
    if(!is.null(test_results$seasonal_test) && test_results$seasonal_test) {
      if(!is.null(test_results$seasonal_ratio)) {
        seasonal_result <- ifelse(test_results$seasonal_ratio < 0.1, 
                               "PASS (no remaining seasonality)", 
                               "FAIL (seasonality remains)")
        result <- paste0(result, sprintf("  Seasonality ratio: %.3f, %s\n", 
                                      test_results$seasonal_ratio, seasonal_result))
      }
    }
    
    # Check for conflicting results between ACF and Ljung-Box
    if(!is.null(test_results$acf_significant) && length(test_results$lb_tests) > 0) {
      # Use the first lag for simplicity
      first_lb <- test_results$lb_tests[[1]]
      if(!is.null(first_lb)) {
        lb_pass <- first_lb$p.value > 0.05
        if((lb_pass && test_results$acf_significant) || (!lb_pass && !test_results$acf_significant)) {
          result <- paste0(result, "  NOTE: ACF plots and Ljung-Box tests show conflicting results\n")
        }
      }
    }
    
    result <- paste0(result, "\n")
    return(result)
  }

  # Create a layout for the page - plots at the top, text at the bottom
  layout(matrix(c(1, 2), nrow=2, ncol=1), heights=c(0.7, 0.3))
  
  # Plot area: Diagnostic plots (now 6 plots per row)
  par(mar=c(2.5, 2.5, 2, 1), oma=c(0, 0, 2, 0))
  
  # Use standard mfrow for the plots (more reliable than split.screen)
  par(mfrow=c(3, 5))  
  
  # Define models to process
  models_info <- list(
    Manual = list(model = result$best_manual_model, name = result$best_manual_name),
    Auto   = list(model = result$auto_model,   name = result$auto_name),
    TBATS  = list(model = result$tbats_model,  name = result$tbats_name)
  )
  
  all_test_results <- list() # To store all test results
  
  # Plot the diagnostics for each model
  for (model_type in names(models_info)) {
    all_test_results[[model_type]] <- analyze_model(models_info[[model_type]]$model)
    # Add model type label to the left margin of first plot
    mtext(model_type, side=2, line=1, cex=1, adj=0.5)
  }
  
  # Add an overall title
  mtext(paste("Enhanced Residual Diagnostics for Jurisdiction", id), side=3, line=1, outer=TRUE, cex=1.5, font=2)
  
  # Text area: Results
  par(mar=c(1, 1, 1, 1))
  plot.new()
  
  # Format the text results
  text_results <- "MODEL DIAGNOSTIC RESULTS\n\n"
  
  # Add model summaries
  for (model_type in names(models_info)) {
    text_results <- paste0(text_results, format_model_results(model_type, all_test_results[[model_type]], models_info[[model_type]]$name))
  }
  
  # Create comprehensive model selection recommendations
  text_results <- paste0(text_results, "MODEL SELECTION RECOMMENDATION\n")
  
  # Count failures across all tests
  failures <- list()
  for (model_type in names(all_test_results)) {
    failures[[model_type]] <- list(
      lb = 0,
      norm = 0,
      arch = 0,
      seasonal = 0,
      conflict = 0,
      total = 0
    )
    
    # Count Ljung-Box failures
    if(length(all_test_results[[model_type]]$lb_tests) > 0) {
      lb_fails <- sum(sapply(all_test_results[[model_type]]$lb_tests, function(x) x$p.value <= 0.05))
      lb_total <- length(all_test_results[[model_type]]$lb_tests)
      failures[[model_type]]$lb <- lb_fails
      failures[[model_type]]$total <- failures[[model_type]]$total + (lb_fails > 0)
    } else {
      failures[[model_type]]$lb <- NA
      failures[[model_type]]$total <- failures[[model_type]]$total + 1
    }
    
    # Count normality test failures
    if(!is.null(all_test_results[[model_type]]$norm_test)) {
      norm_fail <- all_test_results[[model_type]]$norm_test$p.value <= 0.05
      failures[[model_type]]$norm <- norm_fail
      failures[[model_type]]$total <- failures[[model_type]]$total + norm_fail
    }
    
    # Count ARCH test failures
    if(!is.null(all_test_results[[model_type]]$arch_test)) {
      arch_fail <- all_test_results[[model_type]]$arch_test$p.value <= 0.05
      failures[[model_type]]$arch <- arch_fail
      failures[[model_type]]$total <- failures[[model_type]]$total + arch_fail
    }
    
    # Count seasonality test failures
    if(!is.null(all_test_results[[model_type]]$seasonal_test) && 
       all_test_results[[model_type]]$seasonal_test && 
       !is.null(all_test_results[[model_type]]$seasonal_ratio)) {
      seasonal_fail <- all_test_results[[model_type]]$seasonal_ratio >= 0.1
      failures[[model_type]]$seasonal <- seasonal_fail
      failures[[model_type]]$total <- failures[[model_type]]$total + seasonal_fail
    }
  }
  
  # Find best models
  min_failures <- min(sapply(failures, function(x) x$total))
  best_models <- names(failures)[sapply(failures, function(x) x$total) == min_failures]
  
  # If we have multiple best models, use info criteria to decide
  if(length(best_models) > 1) {
    # Extract AIC values for comparison
    aic_values <- sapply(best_models, function(model) {
      if(length(all_test_results[[model]]$info_criteria) > 0 && !is.null(all_test_results[[model]]$info_criteria$AICc)) {
        return(all_test_results[[model]]$info_criteria$AICc)
      } else if(length(all_test_results[[model]]$info_criteria) > 0 && !is.null(all_test_results[[model]]$info_criteria$AIC)) {
        return(all_test_results[[model]]$info_criteria$AIC)
      } else {
        return(NA)
      }
    })
    
    # Filter out models without AIC/AICc info
    valid_models <- best_models[!is.na(aic_values)]
    if(length(valid_models) > 0) {
      best_model_by_aic <- valid_models[which.min(aic_values[!is.na(aic_values)])]
      text_results <- paste0(text_results, "Best model by combined diagnostics & AIC: ", best_model_by_aic, "\n")
    } else {
      text_results <- paste0(text_results, "Multiple models equally valid by diagnostics: ", paste(best_models, collapse=", "), "\n")
    }
  } else if(length(best_models) == 1) {
    text_results <- paste0(text_results, "Best model by diagnostics: ", best_models, "\n")
  } else {
    text_results <- paste0(text_results, "No clearly superior model found - all have some issues.\n")
  }
  
  # Add specific test failure summaries
  text_results <- paste0(text_results, "\nDiagnostic Test Summary:\n")
  for (model_type in names(failures)) {
    text_results <- paste0(text_results, sprintf("  %s: LB=%s, Norm=%s, ARCH=%s, Season=%s\n",
                                              model_type,
                                              ifelse(is.na(failures[[model_type]]$lb), "NA", 
                                                     ifelse(failures[[model_type]]$lb==0, "✓", "✗")),
                                              ifelse(is.na(failures[[model_type]]$norm), "NA", 
                                                     ifelse(failures[[model_type]]$norm==0, "✓", "✗")),
                                              ifelse(is.na(failures[[model_type]]$arch), "NA", 
                                                     ifelse(failures[[model_type]]$arch==0, "✓", "✗")),
                                              ifelse(is.na(failures[[model_type]]$seasonal), "NA", 
                                                     ifelse(failures[[model_type]]$seasonal==0, "✓", "✗"))))
  }
  
  # Add model selection guidance based on failures
  if(all(sapply(failures, function(x) is.na(x$lb) || x$lb > 0))) {
    text_results <- paste0(text_results, "\nAll models show autocorrelation - model specification may need improvement.\n")
  }
  if(all(sapply(failures, function(x) is.na(x$norm) || x$norm > 0))) {
    text_results <- paste0(text_results, "All residuals non-normal - consider transformation or different model family.\n")
  }
  if(all(sapply(failures, function(x) is.na(x$arch) || x$arch > 0))) {
    text_results <- paste0(text_results, "All models show heteroscedasticity - consider GARCH family models.\n")
  }
  if(all(sapply(failures, function(x) is.na(x$seasonal) || x$seasonal > 0))) {
    text_results <- paste0(text_results, "Seasonal patterns remain - consider additional seasonal components.\n")
  }
  
  # Display the text results at the bottom of the page - adjusted for landscape
  text(0.5, 0.5, text_results, adj=c(0.5, 1), family="mono", cex=0.65)
}

# Function to run diagnostics and save to a single PDF file
run_enhanced_diagnostics_to_pdf <- function(selected_ntd_ids, all_results, output_file = "enhanced_model_diagnostics.pdf") {
  # Create the PDF file in landscape orientation
  pdf(output_file, width=11, height=8.5, paper="USr")
  
  # Add a title page
  plot.new()
  text(0.5, 0.7, "Enhanced Model Diagnostics Report", cex=2, font=2)
  text(0.5, 0.5, paste("Generated on:", format(Sys.time(), "%Y-%m-%d %H:%M:%S")), cex=1.2)
  text(0.5, 0.4, paste("Number of Jurisdictions:", length(selected_ntd_ids)), cex=1.2)
  text(0.5, 0.3, "Includes: Ljung-Box, Normality, Heteroscedasticity, and Seasonality Tests", cex=1)
  
  # Run diagnostics for each jurisdiction on a new page
  for (id in selected_ntd_ids) {
    cat("Processing Jurisdiction", id, "\n")
    # Start a new page for each jurisdiction
    if (id != selected_ntd_ids[1]) {
      plot.new()  # Force a new page
    }
    result <- all_results[[as.character(id)]]
    compare_models_pdf(id, result)
  }
  
  # Close the PDF device
  dev.off()
  
  cat(paste("Enhanced diagnostic report saved to:", output_file), "\n")
}

# Call the function to generate the enhanced report
run_enhanced_diagnostics_to_pdf(selected_ntd_ids, all_results)
```
